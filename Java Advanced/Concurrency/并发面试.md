<details>
<summary>Synchronize实现原理（很难）</summary>

[Synchronize实现原理（很难）](https://blog.csdn.net/zbuger/article/details/51030772)

</details>



<details>
<summary>深入JVM锁机制1-synchronized</summary>

[深入JVM锁机制1-synchronized](https://blog.csdn.net/chen77716/article/details/6618779)

</details>

<details>
<summary>深入JVM锁机制2-Lock</summary>

[深入JVM锁机制2-Lock](https://blog.csdn.net/chen77716/article/details/6641477)

</details>

<details>
<summary>Java中的ReentrantLock和synchronized两种锁定机制的对比</summary>

[Java中的ReentrantLock和synchronized两种锁定机制的对比](https://blog.csdn.net/fw0124/article/details/6672522)

</details>


<details>
<summary>自旋锁</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>


<details>
<summary>偏向锁</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>Cache命中缺失</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>Cache一致性流量</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>本地延迟</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>对称多处理器架构(SMP)和非对称多处理器架构(Non Uniform Memory Access Achitecture)</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>CAS(Compare-And-Swap)</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>CAS(Compare-And-Swap)</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>轻量级锁</summary>

* [JVM 中synchronized的底层实现原理解析](https://blog.csdn.net/HinstenyHisoka/article/details/80864378)

</details>

<details>
<summary>重量级锁</summary>

* [JVM 中synchronized的底层实现原理解析](https://blog.csdn.net/HinstenyHisoka/article/details/80864378)

</details>

<details>
<summary>锁的升级, 降级</summary>
  
* [JVM 中synchronized的底层实现原理解析](https://blog.csdn.net/HinstenyHisoka/article/details/80864378)

</details>

<details>
<summary>Java 多线程全局锁与对象锁</summary>

[Java 多线程全局锁与对象锁](https://blog.csdn.net/weixin_40739833/article/details/80293480)

</details>

---

<details>
<summary>ReentrantLock</summary>


</details>

<details>
<summary>ReentrantReadWriteLock</summary>


</details>

<details>
<summary>StampedLock</summary>


</details>

<details>
<summary>锁膨胀</summary>


</details>



1.有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?

2.高并发情况下，我们系统是如何支撑大量的请求的

3.集群如何同步会话状态

4.负载均衡的原理

5.如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）

6.如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。

7.假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。

8.如何查找造成性能瓶颈出现的位置，是哪个位置照成性能瓶颈。

9.你的项目中使用过缓存机制吗？有没用用户非本地缓存



# 有用的

* [电商那些年，我摸爬打滚出的高并发架构实战精髓](https://blog.csdn.net/u010327957/article/details/52788068)
