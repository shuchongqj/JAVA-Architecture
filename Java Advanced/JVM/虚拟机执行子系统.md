
*  [类文件结构(ClassFile)](#类文件结构(ClassFile))
    *  [数据类型](#数据类型)
    *  [类文件格式](#类文件格式)
    
*  [虚拟机类的加载机制(ClassLoader)](#虚拟机类的加载机制(ClassLoader))
    * [加载，链接与初始化](#加载，链接与初始化)
    
    
  content
  ---
  
  ## 类文件结构(ClassFile)
  ### 数据类型
    虚拟机可操作的数据类型为两类： 原始类型 和 引用类型。 
    虚拟机中有三种引用类型：  类类型 ， 数组类型， 接口类型，这些引用类型的值分别指向动态创建的类实例，数组实例和实现了某个接口的类实例或数组实例
    
  ### 类文件格式
  
  ![Imgur](https://farm5.staticflickr.com/4853/45686134624_361625a45b_o.jpg)
  
   每一个类文件都对应着唯一一个类或接口的定义信息，但是相对地，类和接口并不一定都定义在文件里（比如类或接口也可通过类加载器直接生成），只要符合
   CLASS 文件格式的数据流，即使它不一定是以磁盘文件的形式存在，也称之为类文件。class 文件由字节流组成，32位 64位的数据将通过4个或8个连续的8位字节表示，总是按**大端在前** 的顺序存储。可用在JDK中的API访问：java.io.datainput, java io.dataoutput,java.io.datainputstream,
   java.io.dataoutputstream, 专门用于分析class文件字节码的工具： **Javap**, 使用Javap 的**verbose** 参数输出class文件的字节码内容。
   
   <details>
   <summary>Magic (魔数) </summary>

   头4个字节称为魔数，唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件

   </details>
    
   <details>
   <summary>minor_version(副版本号)</summary>


   </details>

   <details>
   <summary>major_version(主版本号) </summary>

  

   </details>

   <details>
   <summary>constant_pool_count(常量池计数器) </summary>
    class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合，字段表集合，方法表集合等的容量计数器都是从0开始
  
   </details>
   
   <details>
   <summary>constant_pool[]（常量池表）</summary>

   常量池存放两大类常量：
   * 字面量---接近Java语言的常量概念
   * 符号引用
     * 类和接口全限定名(fully qualified name)
     * 字段的名称和描述符
     * 方法的名称和描述符
   
   Java代码在进行编译的时候，并不像c++那样对变量，函数进行“连接”这一步骤，而是在虚拟机加载class文件时动态连接，也就是说在class文件中不会存有各个方法，字段的最终内存布局信息，因此这些字段，方法的符号引用不经过**运行期转换**的话无法得到真正的内存入口地址，当虚拟机运行时，需要从class文件中的常量池中获得对应的符号引用，再在类创建时或运行时解析 翻译到具体的内存地址中。
   常量池中每一项常量都是一个表，共有14中不同的表结构，这14种表都有一个共同的特点，就是表开始的第一位是tag标志位，代表当前这个常量属于哪种常量类型。
   
  ![Imgur](https://farm5.staticflickr.com/4849/46414361921_247e5dd726_o.jpg) 
   
  ![Imgur](https://farm5.staticflickr.com/4806/45501991235_2160198998_o.jpg) 
  
   </details>
  
   
   <details>
   <summary>access_flags(访问标志)</summary>

     访问标志用于标识一些类或者接口层次的信息，表明这是类或接口，是否定义为public类型等
     
  ![Imgur](https://farm5.staticflickr.com/4842/45502729195_6517153f02_o.jpg) 
     
   </details>
  
   <details>
   <summary>this_class（类索引）</summary>

    类索引用于确定这个类的全限定名。指向一个类型为CONSTANT_CLASS_INFO的类描述符常量，通过CONSTANT_CLASS_INFO类型的常量中的索引值可找到定义在
    CONSTANT_UTF8_INFO类型的常量中的全限定名字符串
   
  ![Imgur](https://farm8.staticflickr.com/7816/45508573195_d02f92fcdf_o.jpg) 
  
   </details>
  
   <details>
   <summary>super_class（父类索引）</summary>

   父类索引用于确定这个类的父类的全限定名

   </details>
   
   <details>
   <summary>interfaces_count(接口计数器)</summary>

   
   </details>

   <details>
   <summary>interfaces[](接口表)</summary>

    接口索引集合用来描述这个类实现了哪些接口。
    
   </details>

   <details>
   <summary>fields_count（字段计数器）</summary>

   

   </details>

   <details>
   <summary>fields[]（字段表）</summary>

   字段表用于描述接口或类中声明的变量，**包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量**。字段表集合中不会列出从**超类或父接口中继
   承而来的字段**，但有可能列出原本Java代码中不存在的字段，例如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。
   
  **字段表结构：**
 ![Imgur](https://farm5.staticflickr.com/4819/31481686447_aaba34f0d8_o.jpg) 
 
   **字段表访问标志 （access_flags）**
 ![Imgur](https://farm5.staticflickr.com/4842/46421124651_362eeac972_o.jpg) 
 
 **public，private，protected三个标志最多只能选择其一， final，volatile不能同时选择， 接口中的字段必须有public，static，final标志**
 
 name_index和descriptor_index都是对常量池的引用，
 
 * name_index---
 * descriptor_index---描述符的作用是用来描述字段的数据类型，方法的参数列表（包括数量 类型以及顺序）和返回值，字段表都包含的固定数据项目到
   descriptor_index为止就结束了
 
 **字段描述符 （descriptor_index）**
 ![Imgur](https://farm5.staticflickr.com/4828/46421873611_e33cb53f75_o.jpg) 
  
  
   </details>

   <details>
   <summary>methods_count（方法计数器）</summary>

   

   </details>

   <details>
   <summary>methods（方法表）</summary>

   因为volatile 和 transiert 关键字不能修饰方法，仅 synchronized, native , strictfp, abstract 关键字可以修饰方法。**方法中的Java代码**经过编译器编译成字节码指令后，存放在**方法属性表集合**中一个名为**“Code”**的属性里面，
   
  * 方法重写（Override）
     如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息，但可能会出现由编译器自动添加的方法，最典型的就是类构造器**clinit**
     方法和实例构造器 **init**方法。
  
  * Java代码层面的方法特征签名
  Java代码层面的方法特征签名就是一个方法中各个参数（方法名称 参数顺序以及参数类型）在常量池中的字段符号引用的集合，不包含 **返回值** 在特征签名中，
  
  * 字节码层面的方法特征签名
   字节码层面的方法特征签名就是除了一个方法中各个参数（方法名称 参数顺序以及参数类型），还包括方法返回值以及受查异常表。
  
  * 方法重载（Overload）
    除了要与原方法具有相同的简单名称外，还要求必须拥有一个与原方法不同的特征签名，Java 语言是无法仅仅依靠返回值的不同来对一个已有方法进行重载。 
     
   **方法表结构**
  ![Imgur](https://farm8.staticflickr.com/7870/32549700938_207bdc40b9_o.jpg) 
  
  **方法访问标志**
  ![Imgur](https://farm8.staticflickr.com/7839/46371058752_ae5762fa77_o.jpg) 

   </details>

   <details>
   <summary>attributes_count（属性计数器）</summary>

  
   </details>

   <details>
   <summary>attributes[]（属性表）</summary>

    
   </details>


  ## 虚拟机类的加载机制(ClassLoader)
  ### 加载，链接与初始化
