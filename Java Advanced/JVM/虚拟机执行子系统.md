
*  [类文件结构(ClassFile)](#类文件结构(ClassFile))
    *  [数据类型](#数据类型)
    *  [类文件格式](#类文件格式)
    
*  [虚拟机类的加载机制(ClassLoader)](#虚拟机类的加载机制(ClassLoader))
    * [加载 链接与初始化](#加载-链接与初始化)
      * [加载](#加载)
      * [链接](#链接)
      * [初始化](#初始化)
      * [类加载器](#类加载器)
    
    
  content
  ---
  
  ## 类文件结构(ClassFile)
  ### 数据类型
    虚拟机可操作的数据类型为两类： 原始类型 和 引用类型。 
    虚拟机中有三种引用类型：  类类型 ， 数组类型， 接口类型，这些引用类型的值分别指向动态创建的类实例，数组实例和实现了某个接口的类实例或数组实例
    
  ### 类文件格式
  
  ![Imgur](https://farm5.staticflickr.com/4853/45686134624_361625a45b_o.jpg)
  
   每一个类文件都对应着唯一一个类或接口的定义信息，但是相对地，类和接口并不一定都定义在文件里（比如类或接口也可通过类加载器直接生成），只要符合
   CLASS 文件格式的数据流，即使它不一定是以磁盘文件的形式存在，也称之为类文件。class 文件由字节流组成，32位 64位的数据将通过4个或8个连续的8位字节表示，总是按**大端在前** 的顺序存储。可用在JDK中的API访问：java.io.datainput, java io.dataoutput,java.io.datainputstream,
   java.io.dataoutputstream, 专门用于分析class文件字节码的工具： **Javap**, 使用Javap 的**verbose** 参数输出class文件的字节码内容。
   
   <details>
   <summary>Magic (魔数) </summary>

   头4个字节称为魔数，唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件

   </details>
    
   <details>
   <summary>minor_version(副版本号)</summary>


   </details>

   <details>
   <summary>major_version(主版本号) </summary>

  

   </details>

   <details>
   <summary>constant_pool_count(常量池计数器) </summary>
    class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合，字段表集合，方法表集合等的容量计数器都是从0开始
  
   </details>
   
   <details>
   <summary>constant_pool[]（常量池表）</summary>

   常量池存放两大类常量：
   * 字面量---接近Java语言的常量概念
   * 符号引用
     * 类和接口全限定名(fully qualified name)
     * 字段的名称和描述符
     * 方法的名称和描述符
   
   Java代码在进行编译的时候，并不像c++那样对变量，函数进行“连接”这一步骤，而是在虚拟机加载class文件时动态连接，也就是说在class文件中不会存有各个方法，字段的最终内存布局信息，因此这些字段，方法的符号引用不经过**运行期转换**的话无法得到真正的内存入口地址，当虚拟机运行时，需要从class文件中的常量池中获得对应的符号引用，再在类创建时或运行时解析 翻译到具体的内存地址中。
   常量池中每一项常量都是一个表，共有14中不同的表结构，这14种表都有一个共同的特点，就是表开始的第一位是tag标志位，代表当前这个常量属于哪种常量类型。
   
  ![Imgur](https://farm5.staticflickr.com/4849/46414361921_247e5dd726_o.jpg) 
   
  ![Imgur](https://farm5.staticflickr.com/4806/45501991235_2160198998_o.jpg) 
  
   </details>
  
   
   <details>
   <summary>access_flags(访问标志)</summary>

     访问标志用于标识一些类或者接口层次的信息，表明这是类或接口，是否定义为public类型等
     
  ![Imgur](https://farm5.staticflickr.com/4842/45502729195_6517153f02_o.jpg) 
     
   </details>
  
   <details>
   <summary>this_class（类索引）</summary>

    类索引用于确定这个类的全限定名。指向一个类型为CONSTANT_CLASS_INFO的类描述符常量，通过CONSTANT_CLASS_INFO类型的常量中的索引值可找到定义在
    CONSTANT_UTF8_INFO类型的常量中的全限定名字符串
   
  ![Imgur](https://farm8.staticflickr.com/7816/45508573195_d02f92fcdf_o.jpg) 
  
   </details>
  
   <details>
   <summary>super_class（父类索引）</summary>

   父类索引用于确定这个类的父类的全限定名

   </details>
   
   <details>
   <summary>interfaces_count(接口计数器)</summary>

   
   </details>

   <details>
   <summary>interfaces[](接口表)</summary>

    接口索引集合用来描述这个类实现了哪些接口。
    
   </details>

   <details>
   <summary>fields_count（字段计数器）</summary>

   

   </details>

   <details>
   <summary>fields[]（字段表）</summary>

   字段表用于描述接口或类中声明的变量，**包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量**。字段表集合中不会列出从**超类或父接口中继
   承而来的字段**，但有可能列出原本Java代码中不存在的字段，例如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。
   
  **字段表结构：**
 ![Imgur](https://farm5.staticflickr.com/4819/31481686447_aaba34f0d8_o.jpg) 
 
   **字段表访问标志 （access_flags）**
 ![Imgur](https://farm5.staticflickr.com/4842/46421124651_362eeac972_o.jpg) 
 
 **public，private，protected三个标志最多只能选择其一， final，volatile不能同时选择， 接口中的字段必须有public，static，final标志**
 
 name_index和descriptor_index都是对常量池的引用，
 
 * name_index---
 * descriptor_index---描述符的作用是用来描述字段的数据类型，方法的参数列表（包括数量 类型以及顺序）和返回值，字段表都包含的固定数据项目到
   descriptor_index为止就结束了
 
 **字段描述符 （descriptor_index）**
 ![Imgur](https://farm5.staticflickr.com/4828/46421873611_e33cb53f75_o.jpg) 
  
  
   </details>

   <details>
   <summary>methods_count（方法计数器）</summary>

   

   </details>

   <details>
   <summary>methods（方法表）</summary>

   因为volatile 和 transiert 关键字不能修饰方法，仅 synchronized, native , strictfp, abstract 关键字可以修饰方法。**方法中的Java代码**经过编译器编译成字节码指令后，存放在**方法属性表集合**中一个名为**“Code”**的属性里面，
   
  * 方法重写（Override）
     如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息，但可能会出现由编译器自动添加的方法，最典型的就是类构造器**clinit**
     方法和实例构造器 **init**方法。
  
  * Java代码层面的方法特征签名
  Java代码层面的方法特征签名就是一个方法中各个参数（方法名称 参数顺序以及参数类型）在常量池中的字段符号引用的集合，不包含 **返回值** 在特征签名中，
  
  * 字节码层面的方法特征签名
   字节码层面的方法特征签名就是除了一个方法中各个参数（方法名称 参数顺序以及参数类型），还包括方法返回值以及受查异常表。
  
  * 方法重载（Overload）
    除了要与原方法具有相同的简单名称外，还要求必须拥有一个与原方法不同的特征签名，Java 语言是无法仅仅依靠返回值的不同来对一个已有方法进行重载。 
     
   **方法表结构**
  ![Imgur](https://farm8.staticflickr.com/7870/32549700938_207bdc40b9_o.jpg) 
  
  **方法访问标志**
  ![Imgur](https://farm8.staticflickr.com/7839/46371058752_ae5762fa77_o.jpg) 

   </details>

   <details>
   <summary>attributes_count（属性计数器）</summary>

  
   </details>

   <details>
   <summary>attributes[]（属性表）</summary>
   
   一共21种属性 
  ![Imgur](https://farm5.staticflickr.com/4877/45701855824_069a8a9b40_o.jpg)    
  
  ![Imgur](https://farm5.staticflickr.com/4825/45701853044_03858051fa_o.jpg)    
  
   * code 属性
      code属性出现在方法表的属性集合中，但并非所有的方法都必须存在这个属性，例如接口或抽象类中的方法就不存在CODE属性。
      
      **code属性结构表：**
      
     ![Imgur](https://farm8.staticflickr.com/7875/31485651227_99bf9ec838_o.jpg) 
     
     - attribute_name_index
     - max_stack
     - max_locals
     
     
   * Exceptions属性
     exceptions属性的作用是列举出方法中能抛出的受查异常。
     
     ![Imgur](https://farm5.staticflickr.com/4893/46425200351_36fa769039_o.jpg)   
     
   * linenumbertable属性
   * localvariabletable属性
   * sourcefile 属性
   * constantvalue 属性
   * innerclasses 属性
   * deprecated or synthetic 属性
   * stackmaptable 属性
   * signature 属性
   * bootstrapmethods 属性
  
   </details>


## 虚拟机类的加载机制(ClassLoader)
   虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，于那些在编译时需要进行连接
   工作的语言不同，在Java中，类型的加载，连接和初始化过程都是在程序运行期完成的，Java动态展的特性就是依赖运行期动态加载和动态连接特点实现的，从最基础的applet， jsp 到OSGi 技术，都使用了Java 运行期类加载的特行。
### 加载 链接与初始化
   类从被加载虚拟机内存中开始，到卸载出内存为止，它的生命周期经历了7个阶段, **加载 验证 准备 初始化 卸载** 这5个阶段的顺序是确定的，但**解释阶段**
   则不一定会在类**初始化阶段前**发生，它在某些情况下在**初始化阶段之后**再开始，这是为了支持Java的运行时绑定（动态绑定）
     ![Imgur](https://farm5.staticflickr.com/4866/46385243372_fe5e1ff8de_o.jpg)   
     
#### 加载    
  
   * 类的加载
   * 接口的加载

#### 链接
  * 验证
  * 准备
  * 解析
#### 初始化
  对于**初始化阶段**，虚拟机规范严格规定了有并只有5种情况必须对类进行**初始化**（而加载，验证，准备自然需要在此之前开始）
  * 1. 当使用new 关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个静
  态方法的时候，如果类没有进行过初始化，则需要先触发其初始化，对于静态字段，只有直接定义这个字段的类才会被初始化
       
  * 2. 使用java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
  * 3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
  * 4. 虚拟机会先初始化要执行的主类（包含main（）方法的那个类）
  * 5. 如果一个java.lang.invoke.methodhandle 实例最后的解析结果是REF_getstatic REF_putstatic REF_invokestatic 的方法句柄，并这个方法句柄所对应的类没有初始化，则需要先触发其初始化
  
  
#### 类加载器
