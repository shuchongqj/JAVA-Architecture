

 *  [3.1  虚拟机运行时内存数据区](#31--虚拟机运行时内)
  * [3.1.1  内存公有区域](#311--内存公有区域)
       *  [Java堆](#Java堆 ) (heap)
          *  新生代
          *  老年代
          *  永久区（也就是方法区）
          *  堆中的对象
      *  [方法区](#方法区)
          *  类型的常量池
          *  代码
          *  方法
          *  字段
  * [3.1.2  线程私有区域](#312-- 线程私有区域)
      *  [程序计数器](#程序计数器) (PC)
      *  [Java虚拟机栈](#Java虚拟机栈) (Stack)
          *  Java 栈帧
             *  局部变量
             *  方法参数
             *  操作数栈
             *  常量池指针
             *  方法索引(Method Index)
             *  Class File(类)
             *  父帧(Return Frame)
             *  子帧(next Frame)


# 内容

## 3.1  虚拟机运行时内存数据区

![Imgur](https://farm5.staticflickr.com/4844/44526811110_9affbba6c2_o.jpg)

   Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为几个不同的数据区，有的区域随着 **虚拟机进程的启动** 而存在，有些区域却依赖
   **用户线程** 的启动和结束而建立和销毁。

### 3.1.1  内存公有区域
#### Java堆 
#####   **Java 堆的内存图**
   
   ![Imgur](https://farm5.staticflickr.com/4876/45634912874_19b30292af_o.jpg)
   
   Java的堆随虚拟机启动而创建，是被所有线程共享的一块内存区域，存放**对象实例，string 对象以及数组**，但随**JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换**等优化技术将会导致所有的对象都分配在堆上不是那麽**绝对**了。堆可处于物理上不连序的内存空间中，可展的，（通过参数 -Xmx 和
   -Xms 控制）。如果在堆中没有内存给实例分配，并堆也无法展时，会抛出OUTOFMEMORYERROR. Java 堆是垃圾收集器管理的主要区域，主要采用**分代收集算法**
  进行垃圾清理，堆内存可细分为： 新生代（Eden ,From Survivor, To Survivor ）和老年代。
   
   
#### 方法区
#### 性能监控数据区

### 3.1.2  线程私有区域
#### 程序计数器
   程序计数器是当前线程所执性的字节码的行号指示器，每条线程都有一个独立的程序计数器，如果线程正在执行的是一个Java方法，程序计数器记录的是正在执行
   的虚拟机字节码的地址，如果正在执行的是Native 方法，程序计数器则为空（UNDEFINED）
#### Java虚拟机栈
   每一个Java线程都有自己**私有**的Java 虚拟机栈，这个栈与线程同时建立，用于存储**栈帧**，栈帧用于存储方法执行中的局部变量，中间结果，方法的返回
   结果，主要是两种操作： 压栈和出栈，对栈内的空间连续性没有要求。Java虚拟机栈空间的实现可用两种方式： **1 固定大小，每一条线程的栈容量在线程创建时就确定 2 根据运行状况动态地广展和收缩。**
   
#####   **栈（stack） 的内存图**
![Imgur](https://farm5.staticflickr.com/4881/32477636158_317d00a402_o.png)



