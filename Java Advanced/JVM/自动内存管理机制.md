

 *  [3.1  虚拟机运行时内存数据区](#31--虚拟机运行时内)
  * [3.1.1  内存公有区域](#311--内存公有区域)
       *  [Java堆](#Java堆 ) (heap)
          *  新生代
          *  老年代
          *  永久区（也就是方法区）
          *  堆中的类与对象
      *  [方法区](#方法区)
          *  类型的常量池
          *  代码
          *  方法数据
          *  字段
          *  方法和构造函数的字节码
          *  类 实例 接口初始化时用到的特殊方法
          *  [code cache](#code-cache)
      *   性能监控数据区 
          *  查看perdata
  * [3.1.2  线程私有区域](#312--线程私有区域)
      *  [程序计数器](#程序计数器) (PC)
      *  [Java虚拟机栈](#Java虚拟机栈) (Stack)
          *  Java 栈帧
             *  [局部变量区](#局部变量区)
                *  方法参数
             *  [操作数栈](#操作数栈)
             *  [常量池指针](#常量池指针)
             *  方法索引(Method Index)
             *  Class File(类)
             *  父帧(Return Frame)
             *  子帧(next Frame)
             *  动态连接
             *  方法异常表


# 内容

## 3.1  虚拟机运行时内存数据区

![Imgur](https://farm5.staticflickr.com/4844/44526811110_9affbba6c2_o.jpg)

   Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为几个不同的数据区，有的区域随着 **虚拟机进程的启动** 而存在，有些区域却依赖
   **用户线程** 的启动和结束而建立和销毁。

### 3.1.1  内存公有区域
#### Java堆 
#####   **Java 堆的内存图**
   
   ![Imgur](https://farm5.staticflickr.com/4876/45634912874_19b30292af_o.jpg)
   
   Java的堆随虚拟机启动而创建，是被所有线程共享的一块内存区域，存放**对象实例，string 对象以及数组**，但随**JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换**等优化技术将会导致所有的对象都分配在堆上不是那麽**绝对**了。堆可处于物理上不连序的内存空间中，可展的，（通过参数 -Xmx 和
   -Xms 控制）。如果在堆中没有内存给实例分配，并堆也无法展时，会抛出OUTOFMEMORYERROR. Java 堆是垃圾收集器管理的主要区域，主要采用**分代收集算法**
  进行垃圾清理，堆内存可细分为： 新生代（Eden ,From Survivor, To Survivor ）和老年代。
   
   
#### 方法区
##### code-cache
  在JVM启动期间，解释器模块就会将每个字节码转换成与之等价的机器指令，存放在CODE CACHE中， 在解释器执行时，直接取得相应的机器指令序列在机上运行。

#### 性能监控数据区

### 3.1.2  线程私有区域

#### 程序计数器

   程序计数器是当前线程所执性的字节码的行号指示器，每条线程都有一个独立的程序计数器，如果线程正在执行的是一个Java方法，程序计数器记录的是正在执行
   的虚拟机字节码的地址，如果正在执行的是Native 方法，程序计数器则为空（UNDEFINED）
   
#### Java虚拟机栈

#####   **栈（stack） 的内存图**
![Imgur](https://farm5.staticflickr.com/4827/32491357838_44122ee017_o.jpg)

   每一个Java线程都有自己**私有**的Java 虚拟机栈，这个栈与线程同时建立，用于存储**栈帧**，栈帧用于存储方法执行中的**局部变量，中间结果，方法的返回
   结果**，栈帧具有动态性：在程序运行期间，随函数调用链的变化二动态创建和消亡，引起整个栈的动态伸展或收缩。栈主要是两种操作： 压栈和出栈，当调用一个方法时，为当前方法分配一个帧，帧中存有该方法对应的局部数据，方法执行完后，该方法对应的帧则从栈中弹出，并把**返回结果**存储在调用该方法的**父方法的帧的操作数栈中**，对栈内的空间连续性没有要求。Java虚拟机栈空间的实现可用两种方式： **1. 固定大小，每一条线程的栈容量在线程创建时就确定 2. 根据运行状况动态地广展和收缩**。 
   java开发中，每当我们用new 生成一个对象，对象的引用放在栈中，而对象放在堆中，Java栈上的所有数据都是私有的，任何线程都不能访问另一线程的栈数据，
   所以我们不用考虑**多线程情况下栈数据访问同步**的情况。
   
#### 局部变量区

  局部变量区是一个数组，它的大小在Java程序被编译成CLASS文件时，就在方法的**CODE属性的max_locals数据项**中确定了该方法所需分配的最大局部变量表的容量，容量是以变量槽（Slot）为最小单位，可存放8种数据类型（boolean,byte,char,short int,float, reference 是能从此引用中直接或间接地查找到对象在**Java堆中的起始地址索引**和**方法区中的对象类型数据**, returnAddress 指向了一条字节码指令的地址）,每个Java方法的**局部变量表大小**以及**元素类型**可通过class文件中的**LocalVariableTable**属性得到 ，如果调用方法是**实例方法（非static 方法）**那麽局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，把**“this”** 关键字放在这里，其他参数从1开始放置，虚拟机是利用局部变量表完成**参数值**到**参数列表**的传递过程的，

#### 操作数栈
   操作数栈也被称为操作栈或表达式栈，操作数栈的深度有CODE属性MAX_STACKS在编译期便可确定，操作数栈也是一个数组，但它不是通过索引来访问的，而是通过入栈和出栈来访问的，存储计算时临时数据的存储区域，JVM指令是从操作数栈中而不是从寄存器中取得操作数的，
  
   
#### 常量池指针   
   当JVM执行到需要常量池数据的指令时，会通过栈帧常量池指针访问。

   
   
