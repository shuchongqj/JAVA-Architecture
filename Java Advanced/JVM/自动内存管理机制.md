

 *  [3.1  虚拟机运行时内存数据区](#31--虚拟机运行时内)
  * [3.1.1  内存公有区域](#311--内存公有区域)
       *  [Java堆](#Java堆 ) (heap)
          *  新生代
          *  老年代
          *  永久区（也就是方法区）
          *  堆中的类与对象
      *  [方法区](#方法区)
          *  类型基本描述信息
          *  域
             *  字段域
             *  方法域
             
          *  [运行时常量池](#运行时常量池)
          *  代码
          *  方法数据
          *  字段
          *  方法和构造函数的字节码
          *  [类 实例 接口初始化时用到的特殊方法](#类-实例-接口初始化时用到的特殊方法)
          *  [code cache](#code-cache)
      *   性能监控数据区 
          *  查看perdata
  * [3.1.2  线程私有区域](#312--线程私有区域)
      *  [程序计数器](#程序计数器) (PC)
      *  [Java虚拟机栈](#Java虚拟机栈) (Stack)
          *  Java 栈帧
             *  [局部变量区](#局部变量区)
                *  方法参数
             *  [操作数栈](#操作数栈)
             *  [常量池指针](#常量池指针)
             *  方法索引(Method Index)
             *  Class File(类)
             *  父帧(Return Frame)
             *  子帧(next Frame)
             *  [动态连接](#动态连接)
             *  方法调用正常完成
             *  方法调用异常完成
             *  [栈顶缓存](#栈顶缓存)
  *   [3.1.3  直接内存](#313--直接内存)


# 内容

## 3.1  虚拟机运行时内存数据区

![Imgur](https://farm5.staticflickr.com/4844/44526811110_9affbba6c2_o.jpg)

   Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为几个不同的数据区，有的区域随着 **虚拟机进程的启动** 而存在，有些区域却依赖
   **用户线程** 的启动和结束而建立和销毁。**堆**提供存储Java程序运行当中所创建的**对象空间**，**栈**提供执行线程调用方法时用到的**方法参数**
   ，**局部变量**，**中间结果**，**方法区**存储类的字节码，通过引用堆中对象以及围绕栈进行操作的JVM指令，将堆，栈和方法区联系起来。

### 3.1.1  内存公有区域
#### Java堆 
#####   **Java 堆的内存图**
   
   ![Imgur](https://farm5.staticflickr.com/4876/45634912874_19b30292af_o.jpg)
   
   Java的堆随虚拟机启动而创建，是被所有线程共享的一块内存区域，存放**对象实例，string 对象以及数组**，但随**JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换**等优化技术将会导致所有的对象都分配在堆上不是那麽**绝对**了。堆可处于物理上不连序的内存空间中，可展的，（通过参数 -Xmx 和
   -Xms 控制）。如果在堆中没有内存给实例分配，并堆也无法展时，会抛出OUTOFMEMORYERROR. Java 堆是垃圾收集器管理的主要区域，主要采用**分代收集算法**
  进行垃圾清理，堆内存可细分为： 新生代（Eden ,From Survivor, To Survivor ）和老年代。
   
   
#### 方法区

   方法区在虚拟机启动时创建，仅是逻辑上独立，在物理上并没有独立于堆而存在，而是位于永久代中，由虚拟机所有的线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
   垃圾收集器会收集此区域亦可以**选择不实现垃圾收集**，回收过程主要是针对**常量池**的收集以及**类的卸载**，方法区的容量即可以固定分配也可动态旷展，
   
   
##### 类 实例 接口初始化时用到的特殊方法     
    
   
##### 运行时常量池   
   运行时常量池是方法区的一部分，CLASS文件中的常量池内容将在类加载后进入方法区的运行时常量池中存放，运行时常量池相对于CLASS文件常量池另一特征是**动态性**，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入class文件中常量池的内容才能进入运行时常量池，运行期也可能将新的常量放入池中。

##### code-cache
  在JVM启动期间，解释器模块就会将每个字节码转换成与之等价的机器指令，存放在CODE CACHE中， 在解释器执行时，直接取得相应的机器指令序列在机上运行。

#### 性能监控数据区

### 3.1.2  线程私有区域

#### 程序计数器

   程序计数器是当前线程所执性的字节码的行号指示器，每条线程都有一个独立的程序计数器，如果线程正在执行的是一个Java方法，程序计数器记录的是正在执行
   的虚拟机字节码的地址，如果正在执行的是Native 方法，程序计数器则为空（UNDEFINED）
   
#### Java虚拟机栈

#####   **栈（stack） 的内存图**
![Imgur](https://farm5.staticflickr.com/4827/32491357838_44122ee017_o.jpg)

   每一个Java线程都有自己**私有**的Java 虚拟机栈，这个栈与线程同时建立，用于存储**栈帧**，栈帧用于存储方法执行中的**局部变量，中间结果，方法的返回
   结果**，栈帧具有动态性：在程序运行期间，随函数调用链的变化二动态创建和消亡，引起整个栈的动态伸展或收缩。栈主要是两种操作： 压栈和出栈，当调用一个方法时，为当前方法分配一个帧，帧中存有该方法对应的局部数据，方法执行完后，该方法对应的帧则从栈中弹出，并把**返回结果**存储在调用该方法的**父方法的帧的操作数栈中**，对栈内的空间连续性没有要求。Java虚拟机栈空间的实现可用两种方式： **1. 固定大小，每一条线程的栈容量在线程创建时就确定 2. 根据运行状况动态地广展和收缩**。 
   java开发中，每当我们用new 生成一个对象，对象的引用放在栈中，而对象放在堆中，Java栈上的所有数据都是私有的，任何线程都不能访问另一线程的栈数据，
   所以我们不用考虑**多线程情况下栈数据访问同步**的情况。
   
#### 局部变量区

  局部变量区是一个数组，它的大小在Java程序被编译成CLASS文件时，就在方法的**CODE属性的max_locals数据项**中确定了该方法所需分配的最大局部变量表的容量，容量是以变量槽（Slot）为最小单位，可存放8种数据类型（boolean,byte,char,short int,float, reference 是能从此引用中直接或间接地查找到对象在**Java堆中的起始地址索引**和**方法区中的对象类型数据**, returnAddress 指向了一条字节码指令的地址）,每个Java方法的**局部变量表大小**以及**元素类型**可通过class文件中的**LocalVariableTable**属性得到 ，如果调用方法是**实例方法（非static 方法）**那麽局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，把**“this”** 关键字放在这里，其他参数从1开始放置，虚拟机是利用局部变量表完成**参数值**到**参数列表**的传递过程的，

#### 操作数栈
   操作数栈也被称为操作栈或表达式栈，操作数栈的深度有CODE属性MAX_STACKS在编译期便可确定，操作数栈也是一个数组，但它不是通过索引来访问的，而是通过入栈和出栈来访问的，存储计算时临时数据的存储区域，JVM指令是从操作数栈中而不是从寄存器中取得操作数的，
  
#### 动态连接
   每个栈帧内部都包含一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现**动态链接**，在class文件里，一个方法要调用其他方法或访问成员变量，则需要通过符号引用（symbolic reference），动态链接的作用就是将这些符号引用所表示的方法转换成对实际方法的直接引用。
   
#### 常量池指针   
   当JVM执行到需要常量池数据的指令时，会通过栈帧常量池指针访问。
   
#### 栈顶缓存

![Imgur](https://farm5.staticflickr.com/4808/31458097167_930f7484e5_o.jpg)

   栈顶缓存（top-of-stack cashing）技术主要通过将频繁访问的栈顶元素缓存在CUP硬件寄存器中，大幅减少内存访问次数，提高性能。

   
### 3.1.3  直接内存   

   在JDK1.4中新加入NIO（new input/output）类, 类引入了一种基于通道与缓冲区的I/O方式，它可以使用NATIVE 函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和native堆中来回复制数据，提高性能。






