
# 目录

* [Java 内存模型(JMM)](#Java-内存模型(JMM)])
 
  * [缓存一致性(Cache Coherence)](#缓存一致性)
  * [主内存与工作内存](#主内存与工作内存)
  * [内存间交互操作](#内存间交互操作)
    * [先行发生原则](#先行发生原则 ) 
    * [同步指令](#同步指令)
    * [Volatile变量](#Volatile变量)
* [java与线程](#java与线程)
    * 
* 





# content
## Java 内存模型(JMM)

  内存模型的主要目标是定义程序中各个变量的访问规则， 即在虚拟机中将变量（**包括实例变量 静态字段 数组对象**，但**不包括局部变量与方法参数**，因为他们是**线程私有**的，不会**被共享**，自然就不会存在竟争问题** ）存储到内存和从内存中取出变量这样的底层细节。
  
### 缓存一致性

  ![Imgur](https://farm8.staticflickr.com/7925/31554834957_33238aeec0_o.jpg)
  
### 主内存与工作内存

![Imgur](https://farm8.staticflickr.com/7879/45581772355_30774fdc23_o.jpg)

![Imgur](https://farm8.staticflickr.com/7877/44678081970_0eb2a370d7_o.jpg)
  
### 内存间交互操作  

![Imgur](https://farm8.staticflickr.com/7836/45581875385_c224d4edb8_o.jpg)

![Imgur](https://farm8.staticflickr.com/7924/44678163410_746dff130e_o.jpg)

#### 先行发生原则 
     这个原则非常重要，它是判断数据是否存在竟争，线程是否安全的主要依据，依靠这个原则，我们可通过几条规则一揽子地解决并发环境霞两个操作之间是否可能存在冲突的所有问题。
     
     
     
## java与线程

### 同步指令
   Java虚拟机可支持**方法级的同步**和**方法内部一段指令序列的同步**，这两种同步结构都是使用**管程（monitor）**来支持。
   
   <details>
   <summary>方法级的同步</summary>
  
   方法级的同步是隐式的，就是说无需通过字节码指令来控制，它实现在方法调用和返回操作中，从类文件中的方法常量池的方法结构中的acc_synchronized 访问标志得知方法是否声明为**同步**，  当方法调用时，调用指令将会检查该标志位，如果设置为同步，执行线程就要求先成功持有**管程**，然后才能执行方法，最后当方法完成（无论正常完成或非正常完成） 时释放管程，在方法执行期间，执行线程持有了管程，其他任何线程都无法再获得同一个管程，如果一个同步方法执行期间抛出异常，并在方法内部无法处理此异常，那麽  这同步方法所持有的管程将在异常抛到同步方法之外时自动释放。
   </details>
   
   <details>
   <summary>方法内部一段指令的同步</summary>
 
  同步一段指令通常是由Java语言中的SYNCHRONIZED语句块来表示，虚拟机中由monitorenter和monitorexit两条指令来支持synchronized关键字的操作。

  </details>
  
 ### Volatile变量 
    Volatile的同步机制的性能确实要优于锁（使用synchronized 关键字或 java.util.concurrent包里面的锁）
   <details>
   <summary>Volatile 关键字</summary>
   * Volatile变量的可见性
   * 禁止指令重排序优化
 
 ![Imgur](https://farm5.staticflickr.com/4863/32629568448_6618010cb6_o.jpg) 
 
   </details>
   
   
   
