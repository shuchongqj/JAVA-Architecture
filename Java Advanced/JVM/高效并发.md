
# 目录

* [Java 内存模型(JMM)](#Java-内存模型(JMM)])
 
  * [缓存一致性(Cache Coherence)](#缓存一致性)
  * [主内存与工作内存](#主内存与工作内存)
  * [内存间交互操作](#内存间交互操作)
    * [先行发生原则](#先行发生原则 ) 
    * [同步指令](#同步指令)
    * [Volatile变量](#Volatile变量)
  * [原子性 可见性与有序性](#原子性-可见性与有序性)
* [java与线程](#java与线程)
    * 线程的实现
    * Java线程调度
    * 状态转换
* [线程安全与锁优化](#线程安全与锁优化)





# content
## Java 内存模型(JMM)

  内存模型的主要目标是定义程序中各个变量的访问规则， 即在虚拟机中将变量（**包括实例变量 静态字段 数组对象**，但**不包括局部变量与方法参数**，因为他们是**线程私有**的，不会**被共享**，自然就不会存在竟争问题** ）存储到内存和从内存中取出变量这样的底层细节。java内存模型是围绕着在**并发过程**中如何处理**原子性 可见性与有序性**这3个特征来建立的。
  
### 缓存一致性

  ![Imgur](https://farm8.staticflickr.com/7925/31554834957_33238aeec0_o.jpg)
  
### 主内存与工作内存

![Imgur](https://farm8.staticflickr.com/7879/45581772355_30774fdc23_o.jpg)

![Imgur](https://farm8.staticflickr.com/7877/44678081970_0eb2a370d7_o.jpg)
  
### 内存间交互操作  

![Imgur](https://farm8.staticflickr.com/7836/45581875385_c224d4edb8_o.jpg)

![Imgur](https://farm8.staticflickr.com/7924/44678163410_746dff130e_o.jpg)

#### 先行发生原则 
     这个原则非常重要，它是判断数据是否存在竟争，线程是否安全的主要依据，依靠这个原则，我们可通过几条规则一揽子地解决并发环境霞两个操作之间是否可能存在冲突的所有问题。
     
   java 语言无须任何**同步**手段保障就能成立的先行发生规则：

 ![Imgur](https://farm5.staticflickr.com/4875/32630972158_c801bd768d_o.jpg)

### 原子性 可见性与有序性

 <details>
 <summary>原子性</summary>
 
    基本数据类型的访问操作（read load assign use store write）是具备原子性的,如果需要更大范围的原子性，Java虚拟机提供lock 和unlock操作，反映到Java代码中就是同步块--synchronized关键字，因此在synchronized块之间的操作也具备原子性。
    
 </details>
 
 <details>
 <summary>可见性</summary>
 
   可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java提供3个关键字实现可见性： **Volatile  Synchronized  final**,
 java 内存模型是通过在变量修改后将新值同步回**主内存**，在变量**读取前**从**主内存**刷新变量值这种依赖**主内存**作为传递媒介的方式来实现可见性的，不管是普通变量还是Volatile 变量都是如此，普通变量与Volatile 变量的区别是： Volatile 变量的特征规则保证了**新值能立即同步到主内存，以及每次使用前立即从主内存刷新**，因此 **Volatile 变量**保证了**多线程操作时变量的可见性**，而普通变量不能保证这一点。 synchronized 同步块提供的可见性是：**对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（store write 操作）**， 而final 关键字的可见性是： 被final修饰的字段在构造器中一旦初始化完成，并构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事，其他线程有可能通过这个引用访问到“初始化了一半”的对象）那在其他线程中就能看见final字段的值
 
 </details>
  
 <details>
 <summary>有序性</summary>
  
  java提供了Volatile和Synchronized两个关键字来保证线程之间操作的有序性。在从本线程内观察，所有的操作都是有序的，如果在一个线程中观察另一个线程，所有的操作都是无序的，即工作内存和主内存同步延迟。Volatile关键字本身就包含了禁止指令重排序， 而synchronized 则是由“一个变量在同一时刻只允许一条线程对其进行lock 操作”获的有序性。
  
 </details>

### 同步指令
   Java虚拟机可支持**方法级的同步**和**方法内部一段指令序列的同步**，这两种同步结构都是使用**管程（monitor）**来支持。
   
   <details>
   <summary>方法级的同步</summary>
  
   方法级的同步是隐式的，就是说无需通过字节码指令来控制，它实现在方法调用和返回操作中，从类文件中的方法常量池的方法结构中的acc_synchronized 访问标志得知方法是否声明为**同步**，  当方法调用时，调用指令将会检查该标志位，如果设置为同步，执行线程就要求先成功持有**管程**，然后才能执行方法，最后当方法完成（无论正常完成或非正常完成） 时释放管程，在方法执行期间，执行线程持有了管程，其他任何线程都无法再获得同一个管程，如果一个同步方法执行期间抛出异常，并在方法内部无法处理此异常，那麽  这同步方法所持有的管程将在异常抛到同步方法之外时自动释放。
   </details>
   
   <details>
   <summary>方法内部一段指令的同步</summary>
 
  同步一段指令通常是由Java语言中的SYNCHRONIZED语句块来表示，虚拟机中由monitorenter和monitorexit两条指令来支持synchronized关键字的操作。

  </details>
  
 ### Volatile变量 
    Volatile的同步机制的性能确实要优于锁（使用synchronized 关键字或 java.util.concurrent包里面的锁）
   <details>
   <summary>Volatile 关键字</summary>
 
   * Volatile变量的可见性
   * 禁止指令重排序优化
 
 ![Imgur](https://farm5.staticflickr.com/4863/32629568448_6618010cb6_o.jpg) 
 
   </details>
   
   
## java与线程   

## 线程安全与锁优化
