
# 目录

* [Java 内存模型(JMM)](#Java-内存模型(JMM)])
 
  * [缓存一致性(Cache Coherence)](#缓存一致性)
  * [主内存与工作内存](#主内存与工作内存)
  * [内存间交互操作](#内存间交互操作)
    * [先行发生原则](#先行发生原则 ) 
    * [同步指令](#同步指令)
    * [Volatile变量](#Volatile变量)
  * [原子性 可见性与有序性](#原子性-可见性与有序性)
* [java与线程](#java与线程)
    * [线程的实现](#线程的实现)
    * [Java线程调度](#Java线程调度)
    * [状态转换](#状态转换)
* [线程安全与锁优化](#线程安全与锁优化)
    * [线程安全](#线程安全)
    * [锁优化](#锁优化)




# content
## Java 内存模型(JMM)

  内存模型的主要目标是定义程序中各个变量的访问规则， 即在虚拟机中将变量（**包括实例变量 静态字段 数组对象**，但**不包括局部变量与方法参数**，因为他们是**线程私有**的，不会**被共享**，自然就不会存在竟争问题** ）存储到内存和从内存中取出变量这样的底层细节。java内存模型是围绕着在**并发过程**中如何处理**原子性 可见性与有序性**这3个特征来建立的。
  
### 缓存一致性

  ![Imgur](https://farm8.staticflickr.com/7925/31554834957_33238aeec0_o.jpg)
  
### 主内存与工作内存

![Imgur](https://farm8.staticflickr.com/7879/45581772355_30774fdc23_o.jpg)

![Imgur](https://farm8.staticflickr.com/7877/44678081970_0eb2a370d7_o.jpg)
  
### 内存间交互操作  

![Imgur](https://farm8.staticflickr.com/7836/45581875385_c224d4edb8_o.jpg)

![Imgur](https://farm8.staticflickr.com/7924/44678163410_746dff130e_o.jpg)

#### 先行发生原则 
     这个原则非常重要，它是判断数据是否存在竟争，线程是否安全的主要依据，依靠这个原则，我们可通过几条规则一揽子地解决并发环境霞两个操作之间是否可能存在冲突的所有问题。 时间先后顺序与先行发生原则之间基本没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。
     
   java 语言无须任何**同步**手段保障就能成立的先行发生原则：

 ![Imgur](https://farm5.staticflickr.com/4875/32630972158_c801bd768d_o.jpg)

 ![Imgur](https://farm8.staticflickr.com/7855/45591200675_022942d403_o.jpg)

### 原子性 可见性与有序性

 <details>
 <summary>原子性</summary>
 
    基本数据类型的访问操作（read load assign use store write）是具备原子性的,如果需要更大范围的原子性，Java虚拟机提供lock 和unlock操作，反映到Java代码中就是同步块--synchronized关键字，因此在synchronized块之间的操作也具备原子性。
    
 </details>
 
 <details>
 <summary>可见性</summary>
 
   可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java提供3个关键字实现可见性： **Volatile  Synchronized  final**,
 java 内存模型是通过在变量修改后将新值同步回**主内存**，在变量**读取前**从**主内存**刷新变量值这种依赖**主内存**作为传递媒介的方式来实现可见性的，不管是普通变量还是Volatile 变量都是如此，普通变量与Volatile 变量的区别是： Volatile 变量的特征规则保证了**新值能立即同步到主内存，以及每次使用前立即从主内存刷新**，因此 **Volatile 变量**保证了**多线程操作时变量的可见性**，而普通变量不能保证这一点。 synchronized 同步块提供的可见性是：**对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（store write 操作）**， 而final 关键字的可见性是： 被final修饰的字段在构造器中一旦初始化完成，并构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事，其他线程有可能通过这个引用访问到“初始化了一半”的对象）那在其他线程中就能看见final字段的值
 
 </details>
  
 <details>
 <summary>有序性</summary>
  
  java提供了Volatile和Synchronized两个关键字来保证线程之间操作的有序性。在从本线程内观察，所有的操作都是有序的，如果在一个线程中观察另一个线程，所有的操作都是无序的，即工作内存和主内存同步延迟。Volatile关键字本身就包含了禁止指令重排序， 而synchronized 则是由“一个变量在同一时刻只允许一条线程对其进行lock 操作”获的有序性。
  
 </details>

### 同步指令
   Java虚拟机可支持**方法级的同步**和**方法内部一段指令序列的同步**，这两种同步结构都是使用**管程（monitor）**来支持。
   
   <details>
   <summary>方法级的同步</summary>
  
   方法级的同步是隐式的，就是说无需通过字节码指令来控制，它实现在方法调用和返回操作中，从类文件中的方法常量池的方法结构中的acc_synchronized 访问标志得知方法是否声明为**同步**，  当方法调用时，调用指令将会检查该标志位，如果设置为同步，执行线程就要求先成功持有**管程**，然后才能执行方法，最后当方法完成（无论正常完成或非正常完成） 时释放管程，在方法执行期间，执行线程持有了管程，其他任何线程都无法再获得同一个管程，如果一个同步方法执行期间抛出异常，并在方法内部无法处理此异常，那麽  这同步方法所持有的管程将在异常抛到同步方法之外时自动释放。
   </details>
   
   <details>
   <summary>方法内部一段指令的同步</summary>
 
  同步一段指令通常是由Java语言中的SYNCHRONIZED语句块来表示，虚拟机中由monitorenter和monitorexit两条指令来支持synchronized关键字的操作。

  </details>
  
 ### Volatile变量 
    Volatile的同步机制的性能确实要优于锁（使用synchronized 关键字或 java.util.concurrent包里面的锁）
   <details>
   <summary>Volatile 关键字</summary>
 
   * Volatile变量的可见性
   
     当一个线程修改了volatile变量的值，其他线程能够立即得知这个修改，而普通变量不能做到这一点，普通变量的值在线程间传递需通过主内存来完成，
     
   * 禁止指令重排序优化
   
     volatile屏蔽指令重排序的语义在JDK1.5 版本中才完全修复，此前的JDK中即使将变量声明为volatile也不能完全避免重排序所导致的问题。
     
 ![Imgur](https://farm5.staticflickr.com/4863/32629568448_6618010cb6_o.jpg) 
 
   </details>
   
   
## java与线程   
   在Java语言中，每个已经执行start（）并还没结束的java.lang.Thread 类的实例就代表了一个线程。
   
### 线程的实现
   实现线程主要有3种方式： 
   
   * 使用内核线程实现  
   
     就是直接由操作系统内核支持的线程，由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上，程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口--轻量级进程，每一个轻量级进程都由一个内核线程支持，这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型，因此一个系统支持轻量级进程的数量是有限的
     
   * 使用用户线程实现
   
      几本上现在使用用户线程的程序越来越少，Java最终放弃使用它
      
   * 使用用户线程加轻量级进程混合实现
   
      这种模式下，用户线程与轻量级进程的数量比是不定的，即N:M的关系，这就是多对多的线程模型。许多UNIX系列的操作系统都采用这种线程模型。
      
   * Java线程的实现
   
      Java的线程模型基于**操作系统原生线程模型**来实现，对于SUN JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，而在Solaris平台中，由于操作系统的线程特性可以同时支持一对一及多多的线程模型，因此在Solaris版的JDK 提供两个参数（-XX:+UseLWPSynchronization or -XX:+UseBoundThreads）来明确使用哪种线程模型。
   
### Java线程调度
   线程调度是指系统为线程分配处理器使用权的过程，主要的调度方式有两种
     
  * 协同式线程调度
     
   线程的执行时间由线程本身来控制，线程把自己的工作执行完了后，要主动通知系统切换到另外一个线程上，不存在**同步**的问题，缺点是 线程执行时间不可控制，如果线程编写有问题，一直不通知系统进行切换，程序就会阻塞在那里。
   
  * 抢占式线程调度
     
   Java的线程调度采用的是抢占式线程调度，每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身没有什麽办法），虽然Java线程调度是系统自动完成的，但是在程序中还是可以"建议"系统给某些线程多分配一些执行时间---这项操作可以通过设置线程优先级来完成，Java语言设置了10个级别的线程优先级，在两个线程同时处于READY状态时，优先级越高的线程越容易被系统选择执行，不过，线程优先级并不是绝对的，原因是Java的线程是映射到系统的原生线程，所以线程调度最终还是取决于操作系统。
   
  ![Imgur](https://farm5.staticflickr.com/4819/32635744118_878160059e_o.jpg) 

### 状态转换


## 线程安全与锁优化
### 线程安全
### 锁优化
