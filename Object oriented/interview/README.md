
# 目录

* [面向对象入门](#面向对象入门)
  * [封装-类](#封装)
  * [继承-抽象类](#继承)
  * [多重继承-接口类](#多重继承)
* [面向对象进阶](#面向对象进阶)
  * [java静态类](#java静态类)
  * [java匿名类](#java匿名类)
  * [Java内部类](#Java内部类)
  * [java异常类](#java异常类)

### 面向对象入门

<details>
<summary> 抽象类必须要有抽象方法吗？</summary>
 
 不需要，抽象类不一定非要有抽象方法。

示例代码：

```java

abstract class Cat {
    public static void sayHi() {
        System. out. println("hi~");
    }
}

```

上面代码，抽象类并没有抽象方法但完全可以正常运行。

</details> 

<details>
<summary> 解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）</summary>

抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。

内聚：进行架构设计时的内聚高低是指，设计某个模块或者关注点时，模块或关注点内部的一系列相关功能的相关程度的高低。高内聚提供了更好的可维护性和可复用性。而低内聚的模块则表名模块直接的依赖程度高，那么一旦修改了该模块依赖的对象则无法使用该模块，必须也进行相应的修改才可以继续使用。

耦合：简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。

耦合可以分为以下几种，它们之间的耦合度由高到低排列如下：

1. 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。

2. 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。

3. 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。

4. 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。

5. 标记耦合 。若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。

6. 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。

7. 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。

</details> 


<details>
<summary> 多态的用途和实现原理</summary>

1、编译时多态（又称静态多态）

2、运行时多态（又称动态多态）

重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行时运行的时候调用的是确定的方法。
我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。这也是为什么有时候多态方法又被称为延迟方法的原因。

* 多态通常有两种实现方法：

1、子类继承父类（extends）

2、子类实现接口（implements）

* 多态最大的用途

个人认为在于对设计和架构的复用，更进一步来说，《设计模式》中提倡的针对接口编程而不是针对实现编程就是充分利用多态的典型例子。定义功能和组件时定义接口，实现可以留到之后的流程中。同时一个接口可以有多个实现，甚至于完全可以在一个设计中同时使用一个接口的多种实现。

* 多态实现原理

多态允许具体访问时实现方法的动态绑定。Java对于动态绑定的实现主要依赖于方法表，通过继承和接口的多态实现有所不同。
继承：在执行某个方法时，在方法区中找到该类的方法表，再确认该方法在方法表中的偏移量，找到该方法后如果被重写则直接调用，否则认为没有重写父类该方法，这时会按照继承关系搜索父类的方法表中该偏移量对应的方法。

接口：Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同一个接口的的方法在不同类方法表中的位置就可能不一样了。所以不能通过偏移量的方法，而是通过搜索完整的方法表。

tips：因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是慢于类方法的调用的。

</details>
---
1. 什么是面向对象

2. 面向过程

3. 面向对象的三大基本特征和五大基本原则

4. 平台无关性

5. Java 如何实现的平台无关

6. JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）

7.  值传递

8.值传递、引用传递

3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？

11.抽象类必须要有抽象方法吗？

12.普通类和抽象类有哪些区别？

13.抽象类能使用 final 修饰吗？

14.接口和抽象类有什么区别？

17.抽象类和接口的区别

9. 为什么说 Java 中只有值传递

10. 封装、继承、多态

11. 什么是多态、方法重写与重载

12. Java 的继承与实现

13. 构造函数与默认构造函数

14. 类变量、成员变量和局部变量


15. 成员变量和方法作用域

#### 静态块 静态变量
当类加载器将类加载到JVM中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含this或者super,它们通常被用初始化静态变量。

   [JAVA中静态块、静态变量加载顺序详解](https://blog.csdn.net/Mrzhoug/article/details/51581994)
   
   [静态代码块，构造代码块，构造函数之间的差别及先后执行顺序](https://blog.csdn.net/u011889786/article/details/53364205)  
   
   [Java虚拟机类加载机制——案例分析](https://blog.csdn.net/u013256816/article/details/50837863)
   
   [java中静态属性，静态方法和静态初始化器](https://blog.csdn.net/bzhxuexi/article/details/17606691)


16. Java对象四种引用类型
    * [强引用]()
    * [软引用]()
    * [弱引用]()
    * [虚引用]()


61.为什么要使用克隆？

62.如何实现对象克隆？

63.深拷贝和浅拷贝区别是什么？
71. 关于如何使用clone方法以及浅克隆/深克隆机制
40、Java中的参数传递时传值呢？还是传引用？

### 面向对象进阶
