* Collection
  * List
    * Abstraclist and AbstractSequentialist
    * ArrayList(数组)
    * Vector(数组实现，线程同步)
    * LinkList(链表)
    * Stack
  * Set
    * HashSet(Hash表)
    * TreeSet(二叉树)
    * LinkHashSet(HashSet + LinkedHashMap)
  * Queue  
* Map
  * AbstracMap SortedMap NavigableMap
  * HashMap(数组+链表+红黑树)
  * ConcurrentHashMap
  * HashTable(线程安全)
  * TreeMap(可排序)
  * LinkHashMap
  * WeakHashMap
  * Properties
  
---

<details>
<summary>你了解哪些集合类型？</summary>
 
* ArrayList
* LinkedList
* HashMap
* HashSet
之后，你可能会被问到这样一些问题，比如应该何时使用此种特定类型，它比其他的好在哪里，它是怎么存储数据的以及隐匿在背后的数据结构是什么。最好的方法是尽可能多地了解这些集合类型，因为这类问题几乎是无穷尽的

</details>

<details>
<summary>HashMap 有什么特点？</summary>
 
HashMap 基于Map接口实现，存储键值对时，可以接收 null 为键值。HashMap 是非同步的。

</details>
 
<details>
<summary> HashMap 的工作原理是怎样的？</summary>
 
HashMap 在 Map.Entry 静态内部类实现中存储键值对，使用哈希算法。在 put 和 get 方法中，使用 hashCode() 和 equals() 方法。

调用 put 方法时，使用键值对中的 Key hashCode() 和哈希算法找出存储键值对索引。键值对 Entry 存储在 LinkedList 中，如果存在 Entry，使用 equals() 方法来检查 Key 是否已经存在：如果存在，则覆盖 value；如果不存在，会创建一个新的 Entry 然后保存。
调用 get 方法时，HashMap 使用键值 Key hashCode() 来找到数组中的索引，然后使用 equals() 方法找出正确的 Entry，返回 Entry 中的 Value。
分析：HashMap 中容量、负荷系数和阀值是重要的参数。HashMap 默认的初始容量是16，负荷系数是0.75。阀值 = 负荷系数 x 容量。添加 Entry时，如果 Map 的大小 > 阀值，HashMap 会对 Map 的内容重新哈希，使用更大的容量（容量总是2的幂）。关于 JDK 中的 hash 算法实现以及由此引发的哈希碰撞现象（DDos攻击）都可能是面试的延伸问题。

更新：HashMap初始容量16，static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

</details>

<details>
<summary>能否使用任何类作为 Map 的 key？</summary>

可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：

如果类重写了 equals() 方法，也应该重写 hashCode() 方法。
类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。
如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。
用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。
分析：如果有一个类 MyKey，在 HashMap 中使用它：

```java

HashMap<MyKey, String> myHashMap = new HashMap<MyKey, String>();
 
//传递给 MyKey 的 name 参数被用于 equals() 和 hashCode() 中
MyKey key = new MyKey("Pankaj"); // 假设 hashCode=1234
myHashMap.put(key, "Value");
 
// 以下的代码会改变 key 的 hashCode() 和 equals() 值
key.setName("Amit"); // 假设新的 hashCode=7890
 
//下面会返回 null，因为 HashMap 会尝试查找存储同样索引的 key，而 key 已被改变了，匹配失败，返回 null
System.out.println(myHashMap.get(new MyKey("Pankaj")));

```
这就是为什么 String 通常会用作 HashMap 的 Key，因为 String 的设计是不可变的（immutable）。

</details>

<details>
<summary>插入数据时，ArrayList、LinkedList、Vector谁速度较快？</summary>

ArrayList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。

* Vector 中的方法由于加了 synchronized 修饰，因此 Vector 是线程安全容器，但性能上较ArrayList差。
* LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快。

</details>

<details>
<summary>多线程场景下如何使用 ArrayList？</summary>

ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：

```java

List<String> synchronizedList = Collections.synchronizedList(list);
synchronizedList.add("aaa");
synchronizedList.add("bbb");
for (int i = 0; i < synchronizedList.size(); i++)
{
    System.out.println(synchronizedList.get(i));
}

```

</details>

<details>
<summary>说一下 ArrayList 的优缺点</summary>
 
ArrayList的优点如下：
1. ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。
2. ArrayList 在顺序添加一个元素的时候非常方便。

ArrayList 的缺点如下：

1. 删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。
2. 插入元素的时候，也需要做一次元素复制操作，缺点同上。
ArrayList 比较适合顺序添加、随机访问的场景。

</details>

<details>
<summary>为什么 ArrayList 的 elementData 加上 transient 修饰？</summary>

ArrayList 中的数组定义如下：

```java

private transient Object[] elementData;

```
再看一下 ArrayList 的定义：

```java

public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
        
```

可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：

```java

private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();
        // Write out array length
    s.writeInt(elementData.length);
        // Write out all elements in the proper order.
    for (int i=0; i<size; i++)
        s.writeObject(elementData[i]);
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    
```

每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。

</details>

<details>
<summary>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</summary>

遍历方式有以下几种：

for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。
迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。
foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。
最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。

如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。
如果没有实现该接口，表示不支持 Random Access，如LinkedList。
推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。

</details>

<details>
<summary>如何边遍历边移除 Collection 中的元素？</summary>

边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：

```java

Iterator<Integer> it = list.iterator();
while(it.hasNext()){
    // do something
    it.remove();
}

```

一种最常见的错误代码如下：

```java

for(Integer i : list){
    list.remove(i)
}

```
运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它

</details>


<details>
<summary>Hashcode 的作用 </summary>

对于包含容器类型的程序设计语言来说，基本上都会涉及到 hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。
为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）
也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。

//java.util.HashMap的中put方法的具体实现：

```java

public V put(K key, V value) {
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key.hashCode());
        int i = indexFor(hash, table.length);
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
        addEntry(hash, key, value, i);
        return null;
}

```

put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。

</details>


<details>
 
<summary>有没有可能两个不相等的对象有相同的 hashcode？当两个对象hashcode 相同怎么办？如何获取值对象？</summary>

对于两个对象：

如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；

如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；

如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；

如果两个对象的hashcode值相等，则equals方法得到的结果未知。

总之一句话：**等价对象产生相同整数的哈希码，不同对象不一定要不同的哈希码**。后面两个命题其实就是这句话的逆否命题。

所以，针对上面问题提到的，两个不相等的对象其实就是问的equals为false，那么hashcode不一定是不同，也就是有可能会相同了。为什呢会这样呢？hashCode是所有java对象的固有方法，如果不重载的话，返回的实际上是该对象在jvm的堆上的内存地址，而不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。
后面的问题其实会比较多的出现在Map的面试考察中，
当我们调用Map的get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案：将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！

</details>

<details>
<summary>为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与hashCode 的异同点在哪里?</summary>

这里头牵扯到另外隐含的问题，一并拿出来解决：

1、首先我们为什么需要重写hashCode()方法和equals()方法

2、为什么在重写 equals 方法的时候需要重写 hashCode 方法？

3、如何重写这两个方法?

回答第一个问题：
Java中的超类Object类中定义的equals()方法是用来比较两个引用所指向的对象的内存地址是否一致，Object类中equals()方法的源码

```java

public boolean equals(Object obj) {
       return (this == obj);
}

```

Object类中的hashCode()方法，用native关键字修饰，说明这个方法是个原生函数，也就说这个方法的实现不是用java语言实现的，是使用c/c++实现的，并且被编译成了DLL，由java去调用，jdk源码中不包含。对于不同的平台它们是不同的，java在不同的操作系统中调用不同的native方法实现对操作系统的访问，因为java语言不能直接访问操作系统底层，因为它没有指针。

Java的API文档对hashCode()方法做了详细的说明，这也是我们重写hashCode()方法时的原则【Object类】

public native int hashCode();

我们在定义类时，我们经常会希望两个不同对象的某些属性值相同时就认为他们相同，所以我们要重写equals()方法，但同时也要改写hashCode()方法，所以java中的很多类都重写了这两个方法,例如String类，包装类。

第二个问题：为什么在重写 equals 方法的时候需要重写 hashCode 方法？

Java 对于hashCode方法的规约：

在java应用程序运行时，无论何时多次调用同一个对象时的hsahCode()方法，这个对象的hashCode()方法的返回值必须是同一个int值

如果两个对象equals()返回值为true,则他们的hashCode()也必须返回相同的int值

如果两个对象根据equals()比较是不等的，则hashCode()方法不一定得返回不同的整数。

根据规约，为了保证同一个对象，equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。如果不这样做程序也可以执行，只不过会隐藏bug。比如重写了equals方法，属性相同就认为相同，但不重写hashcode，那么我们再new一个新的对象，当原对象equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，导致混淆，因此就也需要重写hashcode()。【一句话，容易在要求散列存储的时候，把相同对象给放到一个集合】

有这个要求的症结在于，要考虑到类似HashMap、HashTable、HashSet的这种散列的数据类型的运用。

</details>

<details>
<summary>hashCode() 有什么用？与 a.equals(b) 有什么关系？</summary>
 
如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；

如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；

如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；

如果两个对象的hashcode值相等，则equals方法得到的结果未知。

总之一句话：等价对象产生相同整数的哈希码，不同对象不一定要不同的哈希码。后面两个命题其实就是这句话的逆否命题。

</details>

<details>
<summary>hashCode() 和 equals() 方法的重要性体现在什么地方？</summary>

散列存储集合如HashMap的很多函数要基于equal()函数和hashCode()函数。hashCode()用来定位要存放的位置，equal()用来判断是否相等。

那么，相等的概念是什么？

Object版本的equal只是简单地判断是不是同一个实例。但是有的时候，我们想要的的是逻辑上的相等。比如有一个学生类student，有一个属性studentID，只要

studentID相等，不是同一个实例我们也认为是同一学生。当我们认为判定equals的相等应该是逻辑上的相等而不是只是判断是不是内存中的同一个东西的时候，就需要

重写equal()。而涉及到HashMap的时候，重写了equals()，就需要重写hashCode()

</details>

<details>
<summary>Object类hashcode,equals 设计原则？ sun为什么这么设计？ </summary>

在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。

如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。

如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。

以上是摘自Effective Java的原话，下面进行具体解读：

1.同一个对象（没有发生过修改）无论何时调用hashCode()得到的返回值必须一样。

如果一个key对象在put的时候调用hashCode()决定了存放的位置，而在get的时候调用hashCode()得到了不一样的返回值，这个值映射到了一个和原来不一样的地方，那么肯定就找不到原来那个键值对了。

2.hashCode()的返回值相等的对象不一定相等，通过hashCode()和equals()必须能唯一确定一个对象

不相等的对象的hashCode()的结果可以相等。hashCode()在注意关注碰撞问题的时候，也要关注生成速度问题，完美hash不现实。

3.一旦重写了equals()函数（重写equals的时候还要注意要满足自反性、对称性、传递性、一致性），就必须重写hashCode()函数。而且hashCode()的生成哈希值的依据应该是equals()中用来比较是否相等的字段 。如果两个由equals()规定相等的对象生成的hashCode不等，对于hashMap来说，他们很可能分别映射到不同位置，没有调用equals()比较是否相等的机会，两个实际上相等的对象可能被插入不同位置，出现错误。其他一些基于哈希方法的集合类可能也会有这个问题。

</details>

<details>
<summary>Object有哪些公用方法？Object类的概述? </summary>
 
Object是所有类的父类，任何类都默认继承Object。

clone：保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常

equals：在Object中与==是一样的，子类一般需要重写该方法

hashCode：该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到

getClass：final方法，获得运行时类型

wait：使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 调用该方法后当前线程进入睡眠状态，直到以下事件发生：

其他线程调用了该对象的notify方法

其他线程调用了该对象的notifyAll方法

其他线程调用了interrupt中断该线程

时间间隔到了，此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常

notify：唤醒在该对象上等待的某个线程

notifyAll：唤醒在该对象上等待的所有线程

toString：转换成字符串，一般子类都有重写，否则打印句柄



</details>

---

<details>
<summary>你都知道哪些常用的Map集合? </summary>


</details>

<details>
<summary>Collection集合接口和Map接口有什么关系？</summary>


</details>

<details>
<summary>HashMap是线程安全的吗？线程安全的Map都有哪些？性能最好的是哪个？</summary>


</details>

<details>
<summary>使用HashMap有什么性能问题吗？</summary>


</details>

<details>
<summary>HashMap的数据结构是怎样的？默认大小是多少？内部是怎么扩容的？</summary>


</details>

<details>
<summary>怎么按添加顺序存储元素？怎么按A-Z自然顺序存储元素？怎么自定义排序？</summary>


</details>


<details>
<summary>HashMap的链表结构设计是用来解决什么问题的？</summary>


</details>

<details>
<summary>HashMap的键、值可以为NULL吗？HashTable呢？</summary>


</details>

<details>
<summary>HashMap使用对象作为key，如果hashcode相同会怎么处理？</summary>


</details>

<details>
<summary>HashMap中的get操作是什么原理？</summary>


</details>

[这几道Java集合框架面试题在面试中几乎必问](https://zhuanlan.zhihu.com/p/42806127)

18.java 容器都有哪些？

19.Collection 和 Collections 有什么区别？

20.List、Set、Map 之间的区别是什么？

21.HashMap 和 Hashtable 有什么区别？

22.如何决定使用 HashMap 还是 TreeMap？

23.说一下 HashMap 的实现原理？

24.说一下 HashSet 的实现原理？

25.ArrayList 和 LinkedList 的区别是什么？

26.如何实现数组和 List 之间的转换？

27.ArrayList 和 Vector 的区别是什么？

28.Array 和 ArrayList 有何区别？

29.在 Queue 中 poll()和 remove()有什么区别？

30.哪些集合类是线程安全的？

31.迭代器 Iterator 是什么？

32.Iterator 怎么使用？有什么特点？

33.Iterator 和 ListIterator 有什么区别？

34.怎么确保一个集合不能被修改？

2.HashMap的源码，实现原理，底层结构。

3.说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。

4.描述一下ArrayList和LinkedList各自实现和区别

5.Java中的队列都有哪些，有什么区别。
21.Hash冲突怎么办？哪些解决散列冲突的方法？

22.HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）咯，用二叉排序树的思路说了一通

19.Hashtable,HashMap,ConcurrentHashMap底层实现原理与线程安全问题（建议熟悉jdk源码，才能从容应答）

23.rehash

24.hashCode()与equals()生成算法、方法怎么重写
2.HashMap的源码，实现原理，底层结构。

3.说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。

4.描述一下ArrayList和LinkedList各自实现和区别

5.Java中的队列都有哪些，有什么区别。
11.hashtable和hashmap的区别

20.如果不让你用JavaJdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现
