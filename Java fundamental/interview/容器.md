* Collection
  * List
    * Abstraclist and AbstractSequentialist
    * ArrayList(数组)
    * Vector(数组实现，线程同步)
    * LinkList(链表)
    * Stack
  * Set
    * HashSet(Hash表)
    * TreeSet(二叉树)
    * LinkHashSet(HashSet + LinkedHashMap)
  * Queue  
* Map
  * AbstracMap SortedMap NavigableMap
  * HashMap(数组+链表+红黑树)
  * ConcurrentHashMap
  * HashTable(线程安全)
  * TreeMap(可排序)
  * LinkHashMap
  * WeakHashMap
  * Properties
  
---

<details>
<summary>你了解哪些集合类型？</summary>
 
* ArrayList
* LinkedList
* HashMap
* HashSet
之后，你可能会被问到这样一些问题，比如应该何时使用此种特定类型，它比其他的好在哪里，它是怎么存储数据的以及隐匿在背后的数据结构是什么。最好的方法是尽可能多地了解这些集合类型，因为这类问题几乎是无穷尽的

</details>

<details>
<summary>HashMap 有什么特点？</summary>
 
HashMap 基于Map接口实现，存储键值对时，可以接收 null 为键值。HashMap 是非同步的。

</details>
 
<details>
<summary> HashMap 的工作原理是怎样的？</summary>
 
HashMap 在 Map.Entry 静态内部类实现中存储键值对，使用哈希算法。在 put 和 get 方法中，使用 hashCode() 和 equals() 方法。

调用 put 方法时，使用键值对中的 Key hashCode() 和哈希算法找出存储键值对索引。键值对 Entry 存储在 LinkedList 中，如果存在 Entry，使用 equals() 方法来检查 Key 是否已经存在：如果存在，则覆盖 value；如果不存在，会创建一个新的 Entry 然后保存。
调用 get 方法时，HashMap 使用键值 Key hashCode() 来找到数组中的索引，然后使用 equals() 方法找出正确的 Entry，返回 Entry 中的 Value。
分析：HashMap 中容量、负荷系数和阀值是重要的参数。HashMap 默认的初始容量是16，负荷系数是0.75。阀值 = 负荷系数 x 容量。添加 Entry时，如果 Map 的大小 > 阀值，HashMap 会对 Map 的内容重新哈希，使用更大的容量（容量总是2的幂）。关于 JDK 中的 hash 算法实现以及由此引发的哈希碰撞现象（DDos攻击）都可能是面试的延伸问题。

更新：HashMap初始容量16，static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

</details>

<details>
<summary>能否使用任何类作为 Map 的 key？</summary>

可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：

如果类重写了 equals() 方法，也应该重写 hashCode() 方法。
类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。
如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。
用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。
分析：如果有一个类 MyKey，在 HashMap 中使用它：

```java

HashMap<MyKey, String> myHashMap = new HashMap<MyKey, String>();
 
//传递给 MyKey 的 name 参数被用于 equals() 和 hashCode() 中
MyKey key = new MyKey("Pankaj"); // 假设 hashCode=1234
myHashMap.put(key, "Value");
 
// 以下的代码会改变 key 的 hashCode() 和 equals() 值
key.setName("Amit"); // 假设新的 hashCode=7890
 
//下面会返回 null，因为 HashMap 会尝试查找存储同样索引的 key，而 key 已被改变了，匹配失败，返回 null
System.out.println(myHashMap.get(new MyKey("Pankaj")));

```
这就是为什么 String 通常会用作 HashMap 的 Key，因为 String 的设计是不可变的（immutable）。

</details>

<details>
<summary>插入数据时，ArrayList、LinkedList、Vector谁速度较快？</summary>

ArrayList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。

* Vector 中的方法由于加了 synchronized 修饰，因此 Vector 是线程安全容器，但性能上较ArrayList差。
* LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快。

</details>

<details>
<summary>多线程场景下如何使用 ArrayList？</summary>

ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：

```java

List<String> synchronizedList = Collections.synchronizedList(list);
synchronizedList.add("aaa");
synchronizedList.add("bbb");
for (int i = 0; i < synchronizedList.size(); i++)
{
    System.out.println(synchronizedList.get(i));
}

```

</details>

<details>
<summary>说一下 ArrayList 的优缺点</summary>
 
ArrayList的优点如下：
1. ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。
2. ArrayList 在顺序添加一个元素的时候非常方便。

ArrayList 的缺点如下：

1. 删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。
2. 插入元素的时候，也需要做一次元素复制操作，缺点同上。
ArrayList 比较适合顺序添加、随机访问的场景。

</details>

<details>
<summary>为什么 ArrayList 的 elementData 加上 transient 修饰？</summary>

ArrayList 中的数组定义如下：

```java

private transient Object[] elementData;

```
再看一下 ArrayList 的定义：

```java

public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
        
```

可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：

```java

private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();
        // Write out array length
    s.writeInt(elementData.length);
        // Write out all elements in the proper order.
    for (int i=0; i<size; i++)
        s.writeObject(elementData[i]);
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    
```

每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。

</details>

<details>
<summary>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</summary>

遍历方式有以下几种：

for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。
迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。
foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。
最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。

如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。
如果没有实现该接口，表示不支持 Random Access，如LinkedList。
推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。

</details>

<details>
<summary>如何边遍历边移除 Collection 中的元素？</summary>

边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：

```java

Iterator<Integer> it = list.iterator();
while(it.hasNext()){
    // do something
    it.remove();
}

```

一种最常见的错误代码如下：

```java

for(Integer i : list){
    list.remove(i)
}

```
运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它

</details>


<details>
<summary>Hashcode 的作用 </summary>

对于包含容器类型的程序设计语言来说，基本上都会涉及到 hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。
为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）
也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。

//java.util.HashMap的中put方法的具体实现：

···java

public V put(K key, V value) {
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key.hashCode());
        int i = indexFor(hash, table.length);
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
        addEntry(hash, key, value, i);
        return null;
}

```

put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。

</details>

---

<details>
<summary>你都知道哪些常用的Map集合? </summary>


</details>

<details>
<summary>Collection集合接口和Map接口有什么关系？</summary>


</details>

<details>
<summary>HashMap是线程安全的吗？线程安全的Map都有哪些？性能最好的是哪个？</summary>


</details>

<details>
<summary>使用HashMap有什么性能问题吗？</summary>


</details>

<details>
<summary>HashMap的数据结构是怎样的？默认大小是多少？内部是怎么扩容的？</summary>


</details>

<details>
<summary>怎么按添加顺序存储元素？怎么按A-Z自然顺序存储元素？怎么自定义排序？</summary>


</details>


<details>
<summary>HashMap的链表结构设计是用来解决什么问题的？</summary>


</details>

<details>
<summary>HashMap的键、值可以为NULL吗？HashTable呢？</summary>


</details>

<details>
<summary>HashMap使用对象作为key，如果hashcode相同会怎么处理？</summary>


</details>

<details>
<summary>HashMap中的get操作是什么原理？</summary>


</details>

[这几道Java集合框架面试题在面试中几乎必问](https://zhuanlan.zhihu.com/p/42806127)

18.java 容器都有哪些？

19.Collection 和 Collections 有什么区别？

20.List、Set、Map 之间的区别是什么？

21.HashMap 和 Hashtable 有什么区别？

22.如何决定使用 HashMap 还是 TreeMap？

23.说一下 HashMap 的实现原理？

24.说一下 HashSet 的实现原理？

25.ArrayList 和 LinkedList 的区别是什么？

26.如何实现数组和 List 之间的转换？

27.ArrayList 和 Vector 的区别是什么？

28.Array 和 ArrayList 有何区别？

29.在 Queue 中 poll()和 remove()有什么区别？

30.哪些集合类是线程安全的？

31.迭代器 Iterator 是什么？

32.Iterator 怎么使用？有什么特点？

33.Iterator 和 ListIterator 有什么区别？

34.怎么确保一个集合不能被修改？

2.HashMap的源码，实现原理，底层结构。

3.说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。

4.描述一下ArrayList和LinkedList各自实现和区别

5.Java中的队列都有哪些，有什么区别。
21.Hash冲突怎么办？哪些解决散列冲突的方法？

22.HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）咯，用二叉排序树的思路说了一通

19.Hashtable,HashMap,ConcurrentHashMap底层实现原理与线程安全问题（建议熟悉jdk源码，才能从容应答）

23.rehash

24.hashCode()与equals()生成算法、方法怎么重写
2.HashMap的源码，实现原理，底层结构。

3.说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。

4.描述一下ArrayList和LinkedList各自实现和区别

5.Java中的队列都有哪些，有什么区别。
11.hashtable和hashmap的区别

20.如果不让你用JavaJdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现
